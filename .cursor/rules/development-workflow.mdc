---
alwaysApply: false
---
## ğŸ”’ Sicherheit - KRITISCH!

### Environment Variables
```bash
# âœ… Frontend (.env)
VITE_SUPABASE_URL=https://xxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGc...  # âœ… Anon Key ist OK fÃ¼r Frontend

# âŒ NIEMALS im Frontend:
SUPABASE_SERVICE_ROLE_KEY=xxx  # â›” NUR Backend/Worker!
SMTP_PASSWORD=xxx              # â›” NUR Backend!
API_SECRET=xxx                 # â›” NUR Backend!
```

### Input Validation
```typescript
// âœ… IMMER validieren vor Supabase Queries
function isValidDomain(domain: string): boolean {
  const domainRegex = /^[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,}$/i
  return domainRegex.test(domain) && domain.length <= 255
}

// âœ… Sanitize User Input
const sanitizedInput = domain.trim().toLowerCase()
if (!isValidDomain(sanitizedInput)) {
  throw new Error('UngÃ¼ltige Domain')
}

// âŒ NIEMALS ungeprÃ¼fte Inputs direkt verwenden
await supabase.from('assets').insert({ host: userInput }) // GEFÃ„HRLICH!
```

### XSS Prevention
```typescript
// âœ… React escapt automatisch, ABER:
// âŒ Vorsicht bei dangerouslySetInnerHTML
<div dangerouslySetInnerHTML={{ __html: userContent }} /> // VERBOTEN!

// âœ… Stattdessen: Text als Children
<div>{userContent}</div>

// âœ… Oder Libraries wie DOMPurify fÃ¼r HTML
import DOMPurify from 'dompurify'
const clean = DOMPurify.sanitize(userHtml)
```

### Authentifizierung
```typescript
// âœ… Protected Routes Pattern
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth()

  if (loading) return <LoadingSpinner />
  if (!user) return <Navigate to="/login" />

  return <>{children}</>
}

// âœ… IMMER prÃ¼fen ob User eingeloggt ist
const { data: { user }, error } = await supabase.auth.getUser()
if (!user) throw new Error('Nicht authentifiziert')

// âœ… RLS schÃ¼tzt auf DB-Ebene (Supabase macht das automatisch)
// Trotzdem: IMMER tenant_id mitgeben fÃ¼r klarheit
const { data } = await supabase
  .from('certificates')
  .select('*')
  .eq('tenant_id', currentTenantId) // Explizit filtern
```

### Secrets Management
```typescript
// âœ… RICHTIG: Secrets nur im Backend
// Worker/Edge Function:
const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

// âŒ FALSCH: Secrets im Frontend Code
const API_KEY = 'sk_live_12345...' // NIEMALS!

// âŒ FALSCH: Secrets in Git
// .env Dateien MÃœSSEN in .gitignore!
```

---

## ğŸš€ Error Handling

### Frontend Error Boundaries
```typescript
// âœ… IMMER Error Boundaries fÃ¼r Komponenten
class ErrorBoundary extends React.Component {
  componentDidCatch(error: Error) {
    console.error('Component error:', error)
    // Optional: Sentry/Logging Service
  }
  render() {
    if (this.state.hasError) {
      return <ErrorFallback />
    }
    return this.props.children
  }
}

// âœ… Try-Catch fÃ¼r Async Operationen
async function handleSubmit() {
  try {
    await scanDomain(domain)
    toast.success('Scan gestartet')
  } catch (error) {
    if (error instanceof Error) {
      toast.error(`Fehler: ${error.message}`)
    }
    console.error('Scan failed:', error)
  }
}

// âŒ Keine ungefangenen Promises
scanDomain(domain) // FALSCH - kein await, kein .catch()
```

### API Error Handling
```typescript
// âœ… Supabase Errors korrekt behandeln
const { data, error } = await supabase
  .from('certificates')
  .select('*')

if (error) {
  // Log fÃ¼r Debugging
  console.error('Supabase error:', error.message, error.details)
  
  // User-friendly Message
  if (error.code === 'PGRST116') {
    throw new Error('Keine Berechtigung')
  } else if (error.code === '23505') {
    throw new Error('Eintrag existiert bereits')
  } else {
    throw new Error('Datenbankfehler')
  }
}

return data
```

---

## âš¡ Performance

### React Performance
```typescript
// âœ… useMemo fÃ¼r teure Berechnungen
const sortedCerts = useMemo(() => {
  return certificates.sort((a, b) => 
    new Date(a.not_after).getTime() - new Date(b.not_after).getTime()
  )
}, [certificates])

// âœ… useCallback fÃ¼r Event Handlers (wenn an Kinder Ã¼bergeben)
const handleClick = useCallback(() => {
  setSelected(id)
}, [id])

// âœ… React.memo fÃ¼r Pure Components
export const CertificateCard = memo(({ cert }: Props) => {
  return <div>...</div>
})

// âŒ Keine Inline-Funktionen in Listen
{certs.map(c => (
  <Card onClick={() => select(c.id)} /> // FALSCH - re-renders
))}
```

### Lazy Loading & Code Splitting
```typescript
// âœ… Route-based Code Splitting
const routes = [
  { path: '/dashboard', element: lazy(() => import('./pages/Dashboard')) },
  { path: '/settings', element: lazy(() => import('./pages/Settings')) }
]

// âœ… Suspense fÃ¼r Lazy Components
<Suspense fallback={<LoadingSpinner />}>
  <LazyComponent />
</Suspense>

// âœ… Dynamic Imports fÃ¼r groÃŸe Dependencies
const handleExport = async () => {
  const { exportToPDF } = await import('./utils/pdf-export')
  await exportToPDF(data)
}
```

### Supabase Performance
```typescript
// âœ… Select nur benÃ¶tigte Felder
const { data } = await supabase
  .from('certificates')
  .select('id, subject_cn, not_after') // Nicht: .select('*')
  .limit(50)

// âœ… Pagination
const { data } = await supabase
  .from('certificates')
  .select('*')
  .range(page * pageSize, (page + 1) * pageSize - 1)

// âœ… Realtime nur fÃ¼r nÃ¶tige Tabellen
const channel = supabase
  .channel('cert-changes')
  .on('postgres_changes', {
    event: 'UPDATE',
    schema: 'public',
    table: 'certificates',
    filter: `tenant_id=eq.${tenantId}` // IMMER filtern!
  }, handler)
  .subscribe()

// âš ï¸ Channel unsubscribe nicht vergessen!
return () => { channel.unsubscribe() }
```

---

## ğŸ§ª Testing (Minimal, nicht Ã¼bertreiben!)

### Unit Tests (nur fÃ¼r komplexe Logik)
```typescript
// âœ… Nur kritische Business-Logik testen
test('calculates days until expiry correctly', () => {
  const cert = { not_after: '2025-12-31T00:00:00Z' }
  const days = getDaysUntilExpiry(cert)
  expect(days).toBeGreaterThan(0)
})

// âŒ NICHT jede kleine Funktion testen
test('formats date correctly', () => { ... }) // UNNÃ–TIG
```

### Component Tests (nur fÃ¼r kritische Komponenten)
```typescript
// âœ… Kritische User Flows testen
test('shows error when login fails', async () => {
  render(<Login />)
  await userEvent.type(screen.getByLabelText('Email'), 'invalid@email')
  await userEvent.click(screen.getByRole('button', { name: 'Login' }))
  expect(screen.getByText(/fehler/i)).toBeInTheDocument()
})

// âŒ Keine Snapshot Tests fÃ¼r alles
```

---

## ğŸ“ Code Style

### Naming Conventions
```typescript
// âœ… Komponenten: PascalCase
export function CertificateList() {}

// âœ… Hooks: camelCase mit "use" Prefix
export function useCertificates() {}

// âœ… Utilities: camelCase
export function formatDate() {}

// âœ… Konstanten: UPPER_SNAKE_CASE
const MAX_RETRIES = 3

// âœ… Types/Interfaces: PascalCase
interface Certificate {}
type Status = 'active' | 'expired'
```

### File Naming
```
âœ… components/CertificateCard.tsx       # PascalCase fÃ¼r Komponenten
âœ… hooks/useCertificates.ts             # camelCase fÃ¼r Hooks
âœ… utils/formatDate.ts                  # camelCase fÃ¼r Utils
âœ… types/database.types.ts              # kebab-case fÃ¼r Types
```

### Import Order
```typescript
// 1. React & External Libraries
import { useState, useEffect } from 'react'
import { supabase } from '@/lib/supabase'

// 2. Internal Components
import { Button } from '@/components/ui/Button'
import { Modal } from '@/components/ui/Modal'

// 3. Hooks & Utils
import { useAuth } from '@/hooks/useAuth'
import { formatDate } from '@/utils/formatDate'

// 4. Types
import type { Certificate } from '@/types/database.types'

// 5. Styles (wenn vorhanden)
import './styles.css'
```

---

## ğŸ¨ UI/UX Best Practices

### Loading States
```typescript
// âœ… IMMER Loading States anzeigen
if (isLoading) return <LoadingSpinner />
if (error) return <ErrorMessage error={error} />
if (!data) return null

// âœ… Skeleton Screens fÃ¼r bessere UX
{isLoading ? (
  <SkeletonCard />
) : (
  <CertificateCard cert={data} />
)}
```

### User Feedback
```typescript
// âœ… Toast Notifications fÃ¼r Actions
import { toast } from 'sonner'

async function deleteCertificate(id: string) {
  try {
    await supabase.from('certificates').delete().eq('id', id)
    toast.success('Zertifikat gelÃ¶scht')
  } catch (error) {
    toast.error('LÃ¶schen fehlgeschlagen')
  }
}

// âœ… Confirmation Modals fÃ¼r destructive Actions
const handleDelete = () => {
  if (confirm('Wirklich lÃ¶schen?')) {
    deleteCertificate(id)
  }
}
```

### Accessibility
```typescript
// âœ… Semantic HTML
<button type="button">Click</button>  // nicht <div onClick>
<nav>...</nav>
<main>...</main>

// âœ… ARIA Labels
<button aria-label="SchlieÃŸen">Ã—</button>

// âœ… Keyboard Navigation
<Modal onClose={handleClose} trapFocus>
```

---

## ğŸ”„ Git Workflow (Kurz & Knapp)

### Commit Messages
```bash
âœ… feat: Add certificate scan functionality
âœ… fix: Resolve login redirect issue
âœ… refactor: Extract API client to separate file
âœ… style: Update button colors to match design system

âŒ "update stuff"
âŒ "fix bug"
âŒ "changes"
```

### Branch Strategy
```bash
# Arbeite direkt auf main fÃ¼r kleine Features
git checkout main
git pull
# ... changes ...
git commit -m "feat: Add domain scanning"
git push

# Bei grÃ¶ÃŸeren Features: Feature Branch
git checkout -b feature/acme-integration
# ... changes ...
git push -u origin feature/acme-integration
```

---

## ğŸ“¦ Dependencies Management

### Nur installieren was wirklich gebraucht wird!
```bash
# âœ… Nur nÃ¶tige Dependencies
npm install date-fns              # Nur date-fns, nicht moment + dayjs + date-fns

# âŒ Keine riesigen Libraries fÃ¼r kleine Features
npm install lodash                # FALSCH - 100KB fÃ¼r eine Funktion
npm install lodash.debounce       # BESSER - nur was gebraucht wird
```

### RegelmÃ¤ÃŸig updaten
```bash
# Security Updates prÃ¼fen
npm audit
npm audit fix

# Dependencies updaten (vorsichtig!)
npm outdated
npm update
```

---

## ğŸ¯ Zusammenfassung - Die 10 Gebote

1. **Keine unnÃ¶tigen Dateien erstellen** - Nur Code, keine Doku-Dateien
2. **TypeScript strict mode** - Keine `any`, keine `@ts-ignore`
3. **Secrets NIE im Frontend** - Nur `VITE_` Variablen, nur Anon Key
4. **Input validieren** - Immer user input prÃ¼fen und sanitizen
5. **Errors behandeln** - Try-Catch, Error Boundaries, User Feedback
6. **Performance beachten** - Lazy Loading, Memo, Code Splitting
7. **RLS vertrauen** - Supabase schÃ¼tzt automatisch, trotzdem explizit filtern
8. **Loading States** - Immer Feedback bei async Operationen
9. **Accessibility** - Semantic HTML, ARIA, Keyboard Support
10. **Keep it simple** - Nicht over-engineeren, YAGNI Prinzip

---

**Diese Regeln gelten ab sofort. Bei VerstÃ¶ÃŸen: Nachfragen, nicht einfach machen!**
