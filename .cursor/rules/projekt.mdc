---
alwaysApply: true
---

# Zertifikat-WÃ¤chter MVP - Cursor Entwicklungsregeln

Du bist ein Senior-Engineer. Baue ein MVP â€žSaaS-Zertifikat-WÃ¤chter" fÃ¼r KMU und IT-Dienstleister. Ziel: simple Ãœberwachung, rechtzeitige Warnungen, leichte Integration. Lieferung als lauffÃ¤higes Monorepo.

## Grundprinzipien

### Code-QualitÃ¤t
- **IMMER** produktionsnahen Code schreiben, KEINE Platzhalter wie "# TODO", "# Implementation here"
- VollstÃ¤ndige Fehlerbehandlung und strukturiertes Logging in allen Komponenten
- Strikte Typisierung: Pydantic fÃ¼r Python, TypeScript fÃ¼r Frontend, strenge Types in Go
- Defensive Programmierung: Input-Validierung, Timeouts, Retry-Logik mit Backoff
- DRY-Prinzip: Gemeinsame Logik in wiederverwendbare Module extrahieren

### Sicherheit First
- **NIEMALS** Secrets im Code: alles Ã¼ber ENV-Variablen
- PasswÃ¶rter nur gehasht (bcrypt/argon2), NIEMALS im Klartext
- SQL Injection Prevention: nur Prepared Statements/ORM
- Rate Limiting auf allen Ã¶ffentlichen Endpunkten
- Input Sanitization und Output Encoding
- CORS richtig konfigurieren
- Audit Log fÃ¼r alle sensitiven Aktionen

### Performance
- Datenbankindizes auf alle Foreign Keys und hÃ¤ufig gefilterte Felder
- Connection Pooling fÃ¼r DB und Redis
- Lazy Loading und Pagination fÃ¼r groÃŸe Listen
- Caching-Strategie mit TTL
- Async/Await korrekt nutzen

## Architektur

### Monorepo-Struktur
```
Zertifikat-WÃ¤chter/
â”œâ”€â”€ backend/          # Python FastAPI
â”œâ”€â”€ worker/           # Python Background Jobs
â”œâ”€â”€ agent/            # Go Edge Connector
â”œâ”€â”€ frontend/         # React TypeScript
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ .env.example
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
```

### Tech Stack (SaaS mit Supabase)
- **Backend/Datenbank**: Supabase (PostgreSQL, Auth, Storage, Realtime, Edge Functions)
- **worker**: Supabase Edge Functions (Deno/TypeScript) fÃ¼r Scans + Alerts, oder Python Worker fÃ¼r komplexe Jobs
- **agent**: Go 1.22, leichtgewichtiger â€žEdge Connector" als Docker Container fÃ¼r Intranet Discovery
- **frontend**: React + TypeScript + Vite, Tailwind, React Query, Supabase Client
- **Auth**: Supabase Auth (Email/Password, OAuth, MFA)
- **Storage**: Supabase Storage fÃ¼r Reports (PDF/CSV)
- **Realtime**: Supabase Realtime fÃ¼r Live-Updates (Alerts, Certificate Status)
- **MandantenfÃ¤higkeit**: Row Level Security (RLS) auf Tenant-Ebene

## Entwicklungsrichtlinien pro Komponente

### Supabase Backend Setup

**Dateistruktur:**
```
supabase/
â”œâ”€â”€ migrations/              # SQL Migrations
â”‚   â”œâ”€â”€ 00001_initial_schema.sql
â”‚   â”œâ”€â”€ 00002_rls_policies.sql
â”‚   â””â”€â”€ ...
â”œâ”€â”€ functions/               # Edge Functions (Deno/TypeScript)
â”‚   â”œâ”€â”€ scan-certificates/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ send-alerts/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ generate-report/
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ seed.sql                 # Demo Daten
â””â”€â”€ config.toml              # Supabase Config
```

**Schema mit RLS (Row Level Security):**
```sql
-- Users sind in auth.users (von Supabase verwaltet)

-- Tenants Tabelle
CREATE TABLE tenants (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Memberships mit RLS
CREATE TABLE memberships (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('owner', 'admin', 'operator', 'auditor', 'external')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(user_id, tenant_id)
);

-- RLS Policy: User sieht nur seine Tenants
ALTER TABLE memberships ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users see own memberships" ON memberships
    FOR SELECT USING (auth.uid() = user_id);

-- Certificates mit Tenant-Isolation
CREATE TABLE certificates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE NOT NULL,
    asset_id UUID REFERENCES assets(id) ON DELETE CASCADE,
    fingerprint TEXT UNIQUE NOT NULL,
    subject_cn TEXT NOT NULL,
    san JSONB,
    issuer TEXT,
    not_before TIMESTAMPTZ NOT NULL,
    not_after TIMESTAMPTZ NOT NULL,
    key_alg TEXT,
    key_size INTEGER,
    serial TEXT,
    is_trusted BOOLEAN DEFAULT false,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indizes fÃ¼r Performance
CREATE INDEX idx_certificates_tenant_id ON certificates(tenant_id);
CREATE INDEX idx_certificates_not_after ON certificates(not_after);
CREATE INDEX idx_certificates_tenant_expiry ON certificates(tenant_id, not_after);
CREATE INDEX idx_certificates_fingerprint ON certificates(fingerprint);

-- RLS: User sieht nur Zertifikate seiner Tenants
ALTER TABLE certificates ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users see tenant certificates" ON certificates
    FOR SELECT USING (
        tenant_id IN (
            SELECT tenant_id FROM memberships WHERE user_id = auth.uid()
        )
    );

-- Funktion fÃ¼r Tenant-Check (wiederverwendbar)
CREATE OR REPLACE FUNCTION user_has_tenant_access(target_tenant_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM memberships 
        WHERE user_id = auth.uid() 
        AND tenant_id = target_tenant_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

**Supabase Edge Function Beispiel:**
```typescript
// supabase/functions/scan-certificates/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    // Get targets to scan
    const { data: assets } = await supabase
      .from('assets')
      .select('*')
      .eq('status', 'active')

    // Scan each asset (call Go agent or scan directly)
    for (const asset of assets || []) {
      // TLS scan logic hier oder Agent API call
      const certData = await scanHost(asset.host, asset.port)
      
      // Upsert certificate
      await supabase
        .from('certificates')
        .upsert({
          tenant_id: asset.tenant_id,
          asset_id: asset.id,
          fingerprint: certData.fingerprint,
          subject_cn: certData.subject_cn,
          not_after: certData.not_after,
          // ... weitere Felder
        }, { onConflict: 'fingerprint' })
    }

    return new Response(JSON.stringify({ success: true }), {
      headers: { 'Content-Type': 'application/json' },
    })
  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})
```

### Worker (Optional: Python fÃ¼r komplexe Jobs)
**Hinweis:** Viele Worker-Tasks kÃ¶nnen als Supabase Edge Functions laufen. FÃ¼r komplexere Jobs (z.B. ACME, PDF-Generierung) kann ein separater Python Worker verwendet werden.

**Verantwortlichkeiten (falls verwendet):**
- Komplexe ACME Renewal Jobs mit certbot
- PDF Report Generation mit ReportLab
- Bulk-Scans Ã¼ber hunderte Hosts

**Python Worker mit Supabase:**
```python
from supabase import create_client, Client
import os

# Supabase Client initialisieren
supabase: Client = create_client(
    os.getenv("SUPABASE_URL"),
    os.getenv("SUPABASE_SERVICE_ROLE_KEY")  # Service Role fÃ¼r Backend-Operationen
)

def scan_certificates_job():
    """Periodischer Scan-Job"""
    # Assets abrufen
    response = supabase.table('assets').select('*').eq('status', 'active').execute()
    
    for asset in response.data:
        try:
            cert_data = scan_host(asset['host'], asset['port'])
            
            # Upsert in Supabase
            supabase.table('certificates').upsert({
                'tenant_id': asset['tenant_id'],
                'asset_id': asset['id'],
                'fingerprint': cert_data['fingerprint'],
                'subject_cn': cert_data['subject_cn'],
                'not_after': cert_data['not_after'].isoformat(),
                # ... weitere Felder
            }, on_conflict='fingerprint').execute()
            
            # Audit Log
            supabase.table('events').insert({
                'tenant_id': asset['tenant_id'],
                'type': 'certificate.scanned',
                'payload': {'asset_id': str(asset['id']), 'fingerprint': cert_data['fingerprint']}
            }).execute()
            
        except Exception as e:
            logger.error(f"Scan failed for {asset}", exc_info=e)
```

**Empfehlung fÃ¼r MVP:** Starte mit Supabase Edge Functions, fÃ¼ge Python Worker nur bei Bedarf hinzu.

### Agent (Go) - Kommuniziert mit Supabase

**Dateistruktur:**
```
agent/
â”œâ”€â”€ main.go
â”œâ”€â”€ config/
â”‚   â””â”€â”€ config.go
â”œâ”€â”€ scanner/
â”‚   â”œâ”€â”€ scanner.go
â”‚   â”œâ”€â”€ tls.go
â”‚   â””â”€â”€ parser.go
â”œâ”€â”€ supabase/
â”‚   â””â”€â”€ client.go         # Supabase REST API Client
â””â”€â”€ Dockerfile
```

**Coding Standards:**
- Errors immer behandeln, keine Panics
- Context fÃ¼r Timeouts und Cancellation
- Strukturiertes Logging (logrus/zap)
- Graceful Shutdown
- Health Endpoint fÃ¼r Kubernetes/Docker
- Supabase Auth mit Service Role Key oder Connector Token

**Supabase Client in Go:**
```go
// supabase/client.go
package supabase

import (
    "bytes"
    "encoding/json"
    "fmt"
    "net/http"
)

type Client struct {
    BaseURL string
    APIKey  string
    client  *http.Client
}

func NewClient(url, apiKey string) *Client {
    return &Client{
        BaseURL: url,
        APIKey:  apiKey,
        client:  &http.Client{Timeout: 10 * time.Second},
    }
}

func (c *Client) UpsertCertificate(cert CertificateData) error {
    url := fmt.Sprintf("%s/rest/v1/certificates", c.BaseURL)
    
    data, err := json.Marshal(cert)
    if err != nil {
        return fmt.Errorf("marshal failed: %w", err)
    }
    
    req, err := http.NewRequest("POST", url, bytes.NewBuffer(data))
    if err != nil {
        return fmt.Errorf("create request failed: %w", err)
    }
    
    req.Header.Set("apikey", c.APIKey)
    req.Header.Set("Authorization", "Bearer "+c.APIKey)
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Prefer", "resolution=merge-duplicates")
    
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("request failed: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode >= 400 {
        return fmt.Errorf("supabase error: %d", resp.StatusCode)
    }
    
    return nil
}
```

**Scanner mit Supabase Integration:**
```go
func ScanAndReport(ctx context.Context, host string, port int, supabaseClient *supabase.Client) error {
    // TLS Scan
    dialer := &net.Dialer{Timeout: 5 * time.Second}
    
    conn, err := tls.DialWithDialer(dialer, "tcp", 
        fmt.Sprintf("%s:%d", host, port),
        &tls.Config{InsecureSkipVerify: true, ServerName: host},
    )
    if err != nil {
        return fmt.Errorf("tls dial failed: %w", err)
    }
    defer conn.Close()
    
    certs := conn.ConnectionState().PeerCertificates
    if len(certs) == 0 {
        return errors.New("no certificates found")
    }
    
    cert := parseCertificate(certs[0])
    
    // An Supabase senden
    return supabaseClient.UpsertCertificate(cert)
}
```

### Frontend (React/TypeScript) mit Supabase

**Dateistruktur:**
```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â””â”€â”€ supabase.ts      # Supabase Client Setup
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ ui/              # Tailwind UI Components
â”‚   â”‚   â”œâ”€â”€ layout/          # Header, Sidebar, Footer
â”‚   â”‚   â””â”€â”€ features/        # Feature-spezifische Components
â”‚   â”œâ”€â”€ pages/
â”‚   â”‚   â”œâ”€â”€ Login.tsx
â”‚   â”‚   â”œâ”€â”€ Dashboard.tsx
â”‚   â”‚   â”œâ”€â”€ Certificates.tsx
â”‚   â”‚   â”œâ”€â”€ Alerts.tsx
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ hooks/               # Custom React Hooks + Supabase Hooks
â”‚   â”‚   â”œâ”€â”€ useCertificates.ts
â”‚   â”‚   â”œâ”€â”€ useAlerts.ts
â”‚   â”‚   â””â”€â”€ useTenant.ts
â”‚   â”œâ”€â”€ stores/              # Zustand fÃ¼r Client State
â”‚   â”œâ”€â”€ types/               # TypeScript Types (Database Types)
â”‚   â””â”€â”€ utils/
â””â”€â”€ package.json
```

**Supabase Setup:**
```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from '../types/database.types' // Generiert via supabase gen types

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey)
```

**Auth mit Supabase:**
```typescript
// hooks/useAuth.ts
import { useEffect, useState } from 'react'
import { User } from '@supabase/supabase-js'
import { supabase } from '../lib/supabase'

export function useAuth() {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Session abrufen
    supabase.auth.getSession().then(({ data: { session } }) => {
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Auth State Changes beobachten
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setUser(session?.user ?? null)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  return { user, loading }
}
```

**Beispiel Component mit Supabase:**
```typescript
// components/CertificateList.tsx
import { useEffect, useState } from 'react'
import { supabase } from '../lib/supabase'
import type { Database } from '../types/database.types'

type Certificate = Database['public']['Tables']['certificates']['Row']

interface CertificateListProps {
  tenantId: string
}

export const CertificateList: React.FC<CertificateListProps> = ({ tenantId }) => {
  const [certificates, setCertificates] = useState<Certificate[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    async function fetchCertificates() {
      try {
        const { data, error } = await supabase
          .from('certificates')
          .select('*')
          .eq('tenant_id', tenantId)
          .order('not_after', { ascending: true })
          .limit(100)

        if (error) throw error
        setCertificates(data || [])
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error')
      } finally {
        setLoading(false)
      }
    }

    fetchCertificates()

    // Realtime Subscription
    const subscription = supabase
      .channel('certificates')
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'certificates',
          filter: `tenant_id=eq.${tenantId}`,
        },
        (payload) => {
          console.log('Certificate changed:', payload)
          fetchCertificates() // Refresh
        }
      )
      .subscribe()

    return () => {
      subscription.unsubscribe()
    }
  }, [tenantId])

  if (loading) return <Spinner />
  if (error) return <ErrorAlert message={error} />
  if (!certificates.length) return <EmptyState message="Keine Zertifikate gefunden" />

  return (
    <div className="space-y-4">
      {certificates.map(cert => (
        <CertificateCard key={cert.id} certificate={cert} />
      ))}
    </div>
  )
}
```

**Login Component:**
```typescript
// pages/Login.tsx
import { useState } from 'react'
import { supabase } from '../lib/supabase'

export function Login() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)

  async function handleLogin(e: React.FormEvent) {
    e.preventDefault()
    setLoading(true)

    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      alert(error.message)
    }
    setLoading(false)
  }

  return (
    <form onSubmit={handleLogin} className="max-w-md mx-auto space-y-4">
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        className="w-full px-4 py-2 border rounded"
      />
      <input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        className="w-full px-4 py-2 border rounded"
      />
      <button
        type="submit"
        disabled={loading}
        className="w-full bg-blue-600 text-white py-2 rounded"
      >
        {loading ? 'Loading...' : 'Login'}
      </button>
    </form>
  )
}
```

## Kernfunktionen
1) Automatische Discovery
   - Public: Scan von Domains und Ports 443, 8443, 853, 993, 995, 636, 10443, 1194, 444, konfigurierbar
   - Intranet: Ã¼ber Agent. Agent macht TLS-Handshake und liefert Metadaten zurÃ¼ck
   - Erkennen: SSL/TLS Zertifikate inkl. SAN, Issuer, NotBefore, NotAfter, KeyAlg, Fingerprint
   - RADIUS, AD, LDAPS: Ports 1812/1813 TLS, 389 StartTLS, 636 LDAPS
   - Dedup durch Fingerprint
2) AblaufÃ¼berwachung
   - Policies pro Asset oder global: Warnschwellen 60, 30, 14, 7, 3, 1 Tage
   - KanÃ¤le: E-Mail, Webhook, Slack, Microsoft Teams
   - Wiederholung bis Quittierung
3) ACME-UnterstÃ¼tzung
   - Public Domains. Provider-Plugins fÃ¼r HTTP-01 und DNS-01
   - Cloudflare und Route53 als Beispielplugins
   - Geplante Auto-Renewals, Report der Aktionen
4) Zentrale Ansicht
   - Dashboard mit Kacheln: Gesamt, bald ablaufend, Ã¼berfÃ¤llig, Fehler
   - Tabellen mit Filter, Suche, Tags, Gruppen, Tenant-Wechsel
5) Integrationen
   - Webhooks, REST API, API Keys pro Tenant
   - Slack App Bot Token, Teams Webhook, SMTP fÃ¼r E-Mail

## Erweiterte Funktionen
- Intranet-UnterstÃ¼tzung durch Agent
- Revisionssichere Logs und Berichte
  - UnverÃ¤nderliche Event-Historie mit Hash-Kette
  - PDF/CSV Exporte fÃ¼r Audits
- Benutzer und Rollen
  - Rollen: Owner, Admin, Operator, Auditor, Externer
  - Least Privilege
- Sicherheit
  - Keine privaten SchlÃ¼ssel speichern
  - Ruhende Daten verschlÃ¼sseln, Secrets via env
  - DSGVO-KonformitÃ¤t, Datenregion konfigurierbar
  - Rate Limits, Audit Log

## Do's and Don'ts

### âœ… IMMER TUN
- Strukturiertes Logging mit Context (tenant_id, user_id, request_id)
- Input Validierung auf allen API-Grenzen
- Transaktionen bei Multi-Step DB Operations
- Indizes auf Foreign Keys und Filter-Felder
- Migrations fÃ¼r Schema-Ã„nderungen (niemals manuelles SQL)
- ENV-Variablen fÃ¼r Konfiguration, .env.example dokumentieren
- README aktuell halten bei neuen Features
- API Versionierung (/api/v1/)
- HTTP Status Codes korrekt nutzen (200, 201, 400, 401, 403, 404, 500)
- Pagination bei Listen-Endpunkten (skip/limit oder cursor-based)
- Tenant-Isolation auf DB-Ebene prÃ¼fen (WHERE tenant_id = ?)
- Graceful Degradation (Feature Flags fÃ¼r neue Features)

### âŒ NIEMALS TUN
- Keine Secrets im Code committen
- Keine privaten SchlÃ¼ssel speichern (nur Public Keys, CSRs)
- Keine SQL-Queries ohne Prepared Statements
- Keine unbehandelten Exceptions
- Keine globalen Variablen fÃ¼r State
- Keine print() Statements (nur Logging)
- Keine hardcoded URLs, IPs, Credentials
- Keine Tenant-Ã¼bergreifenden Abfragen ohne explizite Berechtigung
- Keine synchronen Blocking-Calls in async Endpoints
- Keine unendlichen Loops ohne Exit-Bedingung
- Keine PasswÃ¶rter im Klartext loggen

## Testing-Strategie

### Backend Tests
```python
# Unit Tests fÃ¼r Services
def test_certificate_expiry_calculation():
    cert = Certificate(not_after=datetime.now() + timedelta(days=30))
    assert cert.days_remaining == 30

# API Tests mit TestClient
def test_list_certificates_requires_auth(client):
    response = client.get("/api/v1/certificates")
    assert response.status_code == 401

# Integration Tests mit Test-DB
@pytest.mark.integration
def test_scan_creates_certificate(db_session):
    scan_result = scanner.scan_host("example.com", 443)
    cert = certificate_service.create(db_session, scan_result)
    assert cert.id is not None
```

### Frontend Tests
```typescript
// Component Tests mit React Testing Library
test('renders certificate list', async () => {
  render(<CertificateList tenantId="test" />);
  await waitFor(() => {
    expect(screen.getByText('Certificate 1')).toBeInTheDocument();
  });
});

// API Mock mit MSW
const handlers = [
  rest.get('/api/v1/certificates', (req, res, ctx) => {
    return res(ctx.json([{ id: '1', subject_cn: 'example.com' }]));
  }),
];
```

### Go Tests
```go
func TestScanHost(t *testing.T) {
    ctx := context.Background()
    cert, err := scanner.ScanHost(ctx, "example.com", 443)
    
    if err != nil {
        t.Fatalf("scan failed: %v", err)
    }
    
    if cert.SubjectCN == "" {
        t.Error("expected subject CN")
    }
}
```

## Datenbank Best Practices

### Migrations
- Alembic fÃ¼r Schema-Ã„nderungen
- Descriptive Namen: `2024_10_16_add_certificates_fingerprint_index.py`
- Immer `upgrade()` UND `downgrade()` implementieren
- Daten-Migrationen separat von Schema-Migrationen
- Testen auf leerer DB und mit Seed-Daten

### Indizes
```python
# SQLAlchemy Model mit Indizes
class Certificate(Base):
    __tablename__ = "certificates"
    
    id = Column(UUID, primary_key=True)
    tenant_id = Column(UUID, ForeignKey("tenants.id"), nullable=False, index=True)
    fingerprint = Column(String(64), unique=True, index=True)
    not_after = Column(DateTime, nullable=False, index=True)  # fÃ¼r Expiry Queries
    
    __table_args__ = (
        Index('ix_cert_tenant_expiry', 'tenant_id', 'not_after'),
    )
```

### Query Optimization
- N+1 Problem vermeiden (joinedload, selectinload)
- EXPLAIN ANALYZE fÃ¼r langsame Queries
- Pagination mit Cursor fÃ¼r groÃŸe Datasets
- Aggregate in DB statt in Python (count, sum, avg)

## Dokumentation

### Code-Dokumentation
```python
def scan_certificate(host: str, port: int, timeout: int = 5) -> CertificateMetadata:
    """
    Scannt einen Host auf TLS-Zertifikat.
    
    Args:
        host: Hostname oder IP
        port: TCP Port (typisch 443)
        timeout: Timeout in Sekunden
        
    Returns:
        CertificateMetadata mit allen relevanten Daten
        
    Raises:
        ConnectionError: Wenn Verbindung fehlschlÃ¤gt
        CertificateParseError: Wenn Zertifikat ungÃ¼ltig
    """
```

### API Dokumentation
- OpenAPI/Swagger automatisch generieren (FastAPI macht das)
- Beispiele fÃ¼r Request/Response Bodies
- Error Codes dokumentieren
- Rate Limits dokumentieren

### README Struktur
```markdown
# Zertifikat-WÃ¤chter

## Features
- Automatische Discovery
- AblaufÃ¼berwachung
- ...

## Schnellstart
Docker Compose mit einem Befehl

## Entwicklung
Lokales Setup, Tests ausfÃ¼hren

## Architektur
Komponenten-Ãœbersicht

## API
Link zur OpenAPI Docs

## Sicherheit
Security-Hinweise, Responsible Disclosure

## Lizenz
```

## Datenmodell minimal
- users(id, email, password_hash, mfa_secret, created_at)
- tenants(id, name)
- memberships(user_id, tenant_id, role)
- connectors(id, tenant_id, name, type, status, last_seen, auth_token_hash)
- assets(id, tenant_id, connector_id, host, port, proto, labels jsonb)
- certificates(id, asset_id, fingerprint, subject_cn, san jsonb, issuer, not_before, not_after, key_alg, key_size, serial, is_trusted bool)
- checks(id, certificate_id, ran_at, status, details jsonb)
- alerts(id, certificate_id, level enum, first_triggered_at, last_notified_at, acknowledged_by nullable, acknowledged_at nullable)
- policies(id, tenant_id, warn_days int[], channels jsonb)
- events(id, tenant_id, type, payload jsonb, ts, prev_hash, hash)
- acme_accounts(id, tenant_id, provider, creds_secret_ref)
- acme_orders(id, tenant_id, domain, challenge_type, status, last_error)

## REST API Skizze
- Auth
  - POST /api/auth/login
  - POST /api/auth/refresh
- Tenants
  - GET /api/tenants, POST /api/tenants, POST /api/tenants/{id}/invite
- Connectors
  - POST /api/connectors  erstellt Token und Bootstrap-Script
  - GET /api/connectors  Status und last_seen
- Assets und Zertifikate
  - POST /api/assets/discover  startet Scan Job
  - GET /api/certificates  Filter by tenant, status, expires_before
  - GET /api/certificates/{id}
- Policies und Alerts
  - GET/PUT /api/policies/current
  - GET /api/alerts  acknowledge per POST /api/alerts/{id}/ack
- Integrationen
  - POST /api/integrations/slack
  - POST /api/integrations/teams
  - POST /api/integrations/webhooks
- ACME
  - POST /api/acme/accounts
  - POST /api/acme/orders  body: domain, challenge, provider
  - POST /api/acme/orders/{id}/finalize

OpenAPI generieren. Alle Endpunkte tenant-scoped.

## Agent Spezifikation
- Sprache Go
- LÃ¤uft als Docker Container
- Einmalige Registrierung mit Connector Token
- Periodische Discovery Jobs vom Backend ziehen
- FÃ¼r host:port TLS Handshake, Zertifikat parsen, nur Metadaten posten
- Health Endpoint /healthz
- Konfig per ENV: BACKEND_URL, CONNECTOR_TOKEN, SCAN_TARGETS, SCAN_PORTS, SCAN_INTERVAL

## Scanner Logik
- Portliste konfigurierbar
- TCP connect mit Timeout
- TLS ClientHello mit SNI
- Server Cert Chain holen, End-Entity parsen
- ValiditÃ¤t und Restlaufzeit berechnen
- Ergebnis an /api/ingest/certificates posten
- Retry mit Backoff

## Benachrichtigungen
- E-Mail via SMTP
- Slack via chat.postMessage
- Teams via Incoming Webhook
- Webhook Payload Beispiel:
  {
    "event":"certificate.expiring",
    "tenant_id":"...",
    "certificate_id":"...",
    "asset":{"host":"x","port":443},
    "expires_at":"2025-02-01T00:00:00Z",
    "days_left":14,
    "severity":"warning"
  }

## Frontend Seiten
- Login, MFA Setup
- Tenant Switch
- Dashboard mit Metriken und Charts
- Zertifikate Liste, Detailseite, Historie, Events
- Alerts Liste, Ack Dialog, Policy Editor
- Connectors Setup mit Einzeiler
- Integrationen Setup
- Audit Log mit Filter
- Exporte als CSV und PDF

## ACME Umsetzung
- Bibliothek acme-python oder lego via sidecar
- Provider Plugins fÃ¼r Cloudflare und Route53
- Hintergrundjob fÃ¼r Renewals und Status Updates
- Nur Ã¶ffentliche Domains unterstÃ¼tzen

## Compliance und Audit
- Events als append-only Tabelle
- Hash-Kette: hash = sha256(prev_hash + canonical_json(payload) + ts)
- PDF Bericht â€žCertificate Compliance Reportâ€œ mit Signatur und PrÃ¼fsumme

## Tests
- Unit Tests fÃ¼r Parser und Scanner
- API Tests mit pytest
- E2E Script: starte compose, registriere Connector, scanne localhost, provoziere Alert bei kleinem not_after

## Dev und Deploy
- docker-compose fÃ¼r dev: postgres, redis, minio, backend, worker, frontend, agent-demo
- .env.example mit Variablen
- Migrations via Alembic
- Seed Skript fÃ¼r Demo Daten
- Makefile Targets: up, down, migrate, seed, test

## Akzeptanzkriterien
- Onboarding in unter 10 Minuten mit funktionierendem Connector
- Scan erfasst mindestens 10 gÃ¤ngige Ports und findet Zertifikate auf internen Hosts
- Alerts feuern bei 30, 14, 7 Tagen und lassen sich quittieren
- Dashboard zeigt korrekte ZÃ¤hlungen und Filter
- PDF Audit Report enthÃ¤lt Liste ablaufender Zertifikate und Event-Hash

Liefere produktionsnahen Code, keine Platzhaltertexte. Saubere Fehlerbehandlung, Logging, Typisierung. Schreibe README mit Setup Schritten, Sicherheitsnotizen und Limitierungen.

## Arbeitsablauf mit Cursor

### Bei neuen Features
1. **Verstehen**: Anforderungen genau analysieren, Fragen bei Unklarheiten
2. **Planen**: Ãœberlege welche Dateien betroffen sind (Models, Services, API, Frontend)
3. **Implementieren**: Schritt fÃ¼r Schritt, beginnend mit Backend â†’ Worker â†’ Frontend
4. **Validieren**: Tests schreiben/erweitern, Linter beachten
5. **Dokumentieren**: API Docs aktualisieren, README erweitern bei Bedarf

### Bei Bugs
1. **Reproduzieren**: Verstehe den Fehler genau
2. **Lokalisieren**: Finde die Root Cause (Logs, Stack Traces)
3. **Fixen**: Minimale Ã„nderung, die das Problem lÃ¶st
4. **Testen**: Regression Test hinzufÃ¼gen
5. **Validieren**: Keine neuen Linter-Fehler, Tests grÃ¼n

### Code Review Checkliste
Bevor du Code als fertig markierst:
- [ ] Funktioniert wie erwartet
- [ ] Keine Linter-Fehler
- [ ] Keine Secrets oder Credentials im Code
- [ ] Logging vorhanden
- [ ] Error Handling implementiert
- [ ] Type Hints/Types vollstÃ¤ndig
- [ ] Tests geschrieben (wo sinnvoll)
- [ ] README/Docs aktualisiert (bei neuen Features)
- [ ] Tenant-Isolation gewÃ¤hrleistet
- [ ] Performance OK (keine N+1, Indizes vorhanden)

### Dependencies Management (Supabase Stack)

**Python (requirements.txt) - Optional Worker**
```
# Supabase Client
supabase==2.3.4
postgrest-py==0.13.2

# Utilities
python-dotenv==1.0.0
structlog==23.2.0
httpx==0.25.2
cryptography==41.0.7

# ACME (fÃ¼r Auto-Renewals)
certbot==2.8.0
acme==2.8.0

# PDF Generation
reportlab==4.0.9

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
faker==20.1.0
```

**Frontend (package.json)**
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.20.0",
    "@supabase/supabase-js": "^2.39.0",
    "@supabase/auth-helpers-react": "^0.4.2",
    "zustand": "^4.4.7",
    "tailwindcss": "^3.3.6",
    "date-fns": "^3.0.6",
    "recharts": "^2.10.3"
  },
  "devDependencies": {
    "@types/react": "^18.2.42",
    "typescript": "^5.3.2",
    "vite": "^5.0.5",
    "@vitejs/plugin-react": "^4.2.0",
    "eslint": "^8.54.0",
    "@typescript-eslint/eslint-plugin": "^6.12.0",
    "prettier": "^3.1.0",
    "supabase": "^1.142.0"
  },
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "gen-types": "supabase gen types typescript --local > src/types/database.types.ts"
  }
}
```

**Go (go.mod) - Agent**
```go
module github.com/yourusername/certwatcher-agent

go 1.22

require (
    github.com/sirupsen/logrus v1.9.3
    github.com/joho/godotenv v1.5.1
)
```

**Supabase CLI Setup:**
```bash
# Installiere Supabase CLI
npm install -g supabase

# Initialisiere Projekt
supabase init

# Starte lokale Supabase (fÃ¼r Entwicklung)
supabase start

# Generiere TypeScript Types
supabase gen types typescript --local > frontend/src/types/database.types.ts

# Deploy Migrations
supabase db push

# Deploy Edge Functions
supabase functions deploy scan-certificates
```

### Umgebungsvariablen (.env.example)

**Frontend (.env):**
```bash
# Supabase (NIEMALS SERVICE_ROLE_KEY im Frontend!)
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key-here

# Optional: App Config
VITE_APP_NAME=Zertifikat-WÃ¤chter
VITE_APP_URL=https://app.example.com
```

**Worker/Agent (.env):**
```bash
# Supabase (Service Role fÃ¼r Backend-Operationen)
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here

# SMTP fÃ¼r Alerts
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=alerts@example.com
SMTP_PASSWORD=changeme
SMTP_FROM=alerts@example.com

# Slack (optional)
SLACK_BOT_TOKEN=xoxb-...
SLACK_CHANNEL=#alerts

# Teams (optional)
TEAMS_WEBHOOK_URL=https://outlook.office.com/webhook/...

# Agent
SCAN_INTERVAL=3600
SCAN_PORTS=443,8443,853,993,995,636,10443,1194,444
SCAN_TIMEOUT=5

# Monitoring
LOG_LEVEL=INFO
```

**WICHTIG - Sicherheitshinweise:**
- **NIEMALS** `SUPABASE_SERVICE_ROLE_KEY` im Frontend oder in Git committen!
- `SUPABASE_ANON_KEY` ist sicher fÃ¼r Frontend (hat nur eingeschrÃ¤nkte Rechte via RLS)
- Service Role Key nur fÃ¼r Backend/Worker/Agent verwenden
- Environment Variables Ã¼ber Vercel/Netlify/Railway setzen (fÃ¼r Produktion)
- FÃ¼r lokale Entwicklung: `.env.local` (nicht in Git!)

**Supabase Projekt Setup:**
1. Gehe zu https://supabase.com/dashboard
2. Erstelle neues Projekt
3. Kopiere `Project URL` â†’ `VITE_SUPABASE_URL`
4. Kopiere `anon/public key` â†’ `VITE_SUPABASE_ANON_KEY`
5. Kopiere `service_role key` â†’ `SUPABASE_SERVICE_ROLE_KEY` (nur fÃ¼r Worker/Agent!)
6. Aktiviere Row Level Security (RLS) auf allen Tabellen
7. Aktiviere Realtime fÃ¼r `certificates` und `alerts` Tabellen

### Docker Setup (Vereinfacht mit Supabase)

**Hinweis:** Mit Supabase brauchen wir keine Datenbank/Redis/MinIO Container mehr. Nur fÃ¼r Worker und Agent bei Bedarf.

**docker-compose.yml (Minimal fÃ¼r Agent):**
```yaml
version: '3.8'

services:
  # Agent fÃ¼r Intranet Scans (optional)
  agent:
    build: ./agent
    environment:
      SUPABASE_URL: ${SUPABASE_URL}
      SUPABASE_SERVICE_ROLE_KEY: ${SUPABASE_SERVICE_ROLE_KEY}
      SCAN_INTERVAL: ${SCAN_INTERVAL:-3600}
      SCAN_PORTS: ${SCAN_PORTS:-443,8443,636}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    restart: unless-stopped

  # Optional: Python Worker fÃ¼r ACME/PDF
  worker:
    build: ./worker
    environment:
      SUPABASE_URL: ${SUPABASE_URL}
      SUPABASE_SERVICE_ROLE_KEY: ${SUPABASE_SERVICE_ROLE_KEY}
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USER: ${SMTP_USER}
      SMTP_PASSWORD: ${SMTP_PASSWORD}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    restart: unless-stopped
```

**Agent Dockerfile:**
```dockerfile
# agent/Dockerfile
FROM golang:1.22-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o agent .

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/

COPY --from=builder /app/agent .

EXPOSE 8080
CMD ["./agent"]
```

**Lokale Entwicklung ohne Docker:**
```bash
# Frontend (lokal)
cd frontend
npm install
npm run dev
# LÃ¤uft auf http://localhost:5173

# Agent (lokal)
cd agent
go run main.go
# LÃ¤uft auf http://localhost:8080

# Worker (optional, lokal)
cd worker
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
python main.py
```

**FÃ¼r Produktion:** Frontend auf Vercel/Netlify deployen, Agent auf Railway/Fly.io, Worker auf Render.com

### Makefile Targets (Supabase)
```makefile
.PHONY: help dev setup migrate types test clean

help:
	@echo "Available targets:"
	@echo "  make dev      - Start local development"
	@echo "  make setup    - Initial project setup"
	@echo "  make migrate  - Push database migrations to Supabase"
	@echo "  make types    - Generate TypeScript types from Supabase schema"
	@echo "  make test     - Run all tests"
	@echo "  make clean    - Clean up build artifacts"

dev:
	@echo "Starting Supabase local (optional)..."
	supabase start &
	@echo "Starting frontend..."
	cd frontend && npm run dev

setup:
	@echo "Installing dependencies..."
	cd frontend && npm install
	cd agent && go mod download
	@echo "Setup complete! Run 'make dev' to start."

migrate:
	@echo "Pushing migrations to Supabase..."
	supabase db push

types:
	@echo "Generating TypeScript types..."
	supabase gen types typescript --project-id YOUR_PROJECT_ID > frontend/src/types/database.types.ts

test:
	@echo "Running frontend tests..."
	cd frontend && npm test
	@echo "Running agent tests..."
	cd agent && go test ./...

clean:
	rm -rf frontend/node_modules
	rm -rf frontend/dist
	rm -rf agent/agent
	find . -name "__pycache__" -type d -exec rm -rf {} +
```

## Wichtige Hinweise

### Multi-Tenancy mit Supabase RLS

**Row Level Security (RLS) ist der Hauptmechanismus fÃ¼r Multi-Tenancy in Supabase:**

```sql
-- RLS aktivieren
ALTER TABLE certificates ENABLE ROW LEVEL SECURITY;

-- Policy: User sieht nur Zertifikate seiner Tenants
CREATE POLICY "Users see own tenant certificates" ON certificates
    FOR SELECT USING (
        tenant_id IN (
            SELECT tenant_id FROM memberships 
            WHERE user_id = auth.uid()
        )
    );

-- Policy: User kann nur in eigene Tenants schreiben
CREATE POLICY "Users insert into own tenants" ON certificates
    FOR INSERT WITH CHECK (
        tenant_id IN (
            SELECT tenant_id FROM memberships 
            WHERE user_id = auth.uid()
            AND role IN ('owner', 'admin', 'operator')
        )
    );
```

**Im Frontend:**
```typescript
// âœ… RICHTIG - RLS schÃ¼tzt automatisch
const { data } = await supabase
  .from('certificates')
  .select('*')
  .eq('tenant_id', currentTenantId)
// RLS sorgt dafÃ¼r, dass nur erlaubte Daten zurÃ¼ckkommen

// âŒ FALSCH - Versuche alle Tenants zu lesen
const { data } = await supabase
  .from('certificates')
  .select('*')
// Gibt nur Daten der Tenants zurÃ¼ck, auf die der User Zugriff hat
```

**Im Worker (mit Service Role):**
```python
# Service Role umgeht RLS - VORSICHTIG verwenden!
# Immer explizit tenant_id prÃ¼fen
def send_alert(certificate_id: str, user_id: str):
    # PrÃ¼fe, ob User Zugriff auf Zertifikat hat
    result = supabase.rpc('user_has_certificate_access', {
        'cert_id': certificate_id,
        'uid': user_id
    }).execute()
    
    if not result.data:
        raise PermissionError("No access to certificate")
    
    # Jetzt sicher fortfahren
    ...
```

### Audit Log mit Hash-Kette (Supabase)

```sql
-- Audit Events Tabelle
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tenant_id UUID REFERENCES tenants(id) NOT NULL,
    type TEXT NOT NULL,
    payload JSONB NOT NULL,
    ts TIMESTAMPTZ DEFAULT NOW(),
    prev_hash TEXT NOT NULL DEFAULT '0000000000000000000000000000000000000000000000000000000000000000',
    hash TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index fÃ¼r schnelle Abfrage
CREATE INDEX idx_events_tenant_id ON events(tenant_id);
CREATE INDEX idx_events_ts ON events(ts DESC);

-- RLS
ALTER TABLE events ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users see tenant events" ON events
    FOR SELECT USING (
        tenant_id IN (SELECT tenant_id FROM memberships WHERE user_id = auth.uid())
    );
```

**Supabase Edge Function fÃ¼r Audit Log:**
```typescript
// supabase/functions/create-audit-event/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { createHash } from "https://deno.land/std@0.168.0/node/crypto.ts"

serve(async (req) => {
  const { tenant_id, type, payload } = await req.json()
  
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  )

  // Letzten Event holen
  const { data: lastEvent } = await supabase
    .from('events')
    .select('hash')
    .eq('tenant_id', tenant_id)
    .order('ts', { ascending: false })
    .limit(1)
    .single()

  const prev_hash = lastEvent?.hash || '0'.repeat(64)
  const ts = new Date().toISOString()
  
  // Hash berechnen
  const canonical = JSON.stringify(payload, Object.keys(payload).sort())
  const hash_input = `${prev_hash}${canonical}${ts}`
  const hash = createHash('sha256').update(hash_input).digest('hex')

  // Event speichern
  const { data, error } = await supabase
    .from('events')
    .insert({
      tenant_id,
      type,
      payload,
      ts,
      prev_hash,
      hash
    })
    .select()
    .single()

  if (error) throw error

  return new Response(JSON.stringify(data), {
    headers: { 'Content-Type': 'application/json' },
  })
})
```

**Verwendung im Frontend:**
```typescript
async function logAuditEvent(type: string, payload: any) {
  const { data, error } = await supabase.functions.invoke('create-audit-event', {
    body: {
      tenant_id: currentTenantId,
      type,
      payload
    }
  })
  
  if (error) console.error('Audit log failed:', error)
}
```

### Rate Limiting (Supabase)

**Option 1: Supabase Auth hat eingebautes Rate Limiting**
- Login-Versuche: Automatisch limitiert
- API Calls: Basiert auf Plan (Free: 500 req/sec, Pro: unbegrenzt)

**Option 2: Custom Rate Limiting in Edge Functions**
```typescript
// supabase/functions/_shared/rate-limit.ts
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const RATE_LIMIT_WINDOW = 60 * 1000 // 1 Minute
const MAX_REQUESTS = 10

export async function checkRateLimit(userId: string): Promise<boolean> {
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  )

  const windowStart = new Date(Date.now() - RATE_LIMIT_WINDOW).toISOString()

  const { count } = await supabase
    .from('api_requests')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .gte('created_at', windowStart)

  return (count ?? 0) < MAX_REQUESTS
}
```

**Option 3: Frontend Rate Limiting**
```typescript
// hooks/useRateLimit.ts
import { useState, useEffect } from 'react'

export function useRateLimit(maxRequests: number, windowMs: number) {
  const [requests, setRequests] = useState<number[]>([])

  const canMakeRequest = () => {
    const now = Date.now()
    const windowStart = now - windowMs
    const recentRequests = requests.filter(time => time > windowStart)
    
    if (recentRequests.length >= maxRequests) {
      return false
    }
    
    setRequests([...recentRequests, now])
    return true
  }

  return { canMakeRequest }
}
```

## Zusammenfassung - SaaS-Architektur mit Supabase

### ðŸŽ¯ Hauptvorteile der Supabase-Architektur
1. **Kein Backend-Setup**: PostgreSQL, Auth, Storage out-of-the-box
2. **Schnelles MVP**: Frontend + Supabase â†’ sofort produktionsbereit
3. **Automatische API**: REST & GraphQL durch PostgREST
4. **Realtime Updates**: WebSocket-basierte Live-Updates eingebaut
5. **RLS = Security**: Row Level Security schÃ¼tzt Multi-Tenancy automatisch
6. **TypeScript Types**: Automatisch generiert aus DB Schema
7. **Edge Functions**: Serverless fÃ¼r Worker-Jobs (Deno/TypeScript)
8. **Kosteneffizient**: Free Tier fÃ¼r MVP, skaliert mit Nutzung

### ðŸ—ï¸ Architektur-Ãœbersicht
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Supabase Backend                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚PostgreSQLâ”‚   Auth   â”‚ Storage  â”‚  Edge Functions  â”‚ â”‚
â”‚  â”‚   +RLS   â”‚  +MFA    â”‚ (Reports)â”‚ (Scans/Alerts)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ REST API + Realtime
                       â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚              â”‚              â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚Frontend â”‚   â”‚  Agent  â”‚   â”‚ Worker  â”‚
   â”‚ (React) â”‚   â”‚  (Go)   â”‚   â”‚(Python) â”‚
   â”‚  Vite   â”‚   â”‚ Docker  â”‚   â”‚Optional â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ðŸ“‹ Entwicklungs-Workflow

**1. Supabase Projekt erstellen:**
```bash
# Projekt auf supabase.com erstellen
# Credentials kopieren (URL, anon key, service_role key)
```

**2. Lokales Setup:**
```bash
# Supabase CLI installieren
npm install -g supabase

# Projekt initialisieren
supabase init

# Lokale Supabase starten (optional fÃ¼r Dev)
supabase start

# Frontend erstellen
npm create vite@latest frontend -- --template react-ts
cd frontend
npm install @supabase/supabase-js @supabase/auth-helpers-react
```

**3. Schema erstellen:**
```bash
# Migration erstellen
supabase migration new initial_schema

# In supabase/migrations/XXXXXX_initial_schema.sql:
# - Tabellen definieren
# - RLS Policies erstellen
# - Indizes anlegen

# Zu Supabase pushen
supabase db push
```

**4. TypeScript Types generieren:**
```bash
# Types aus Schema generieren
supabase gen types typescript --local > frontend/src/types/database.types.ts
```

**5. Frontend entwickeln:**
```typescript
// Supabase Client setup
// Auth Hook implementieren
// Components mit Realtime
```

**6. Edge Functions fÃ¼r Worker:**
```bash
# Edge Function erstellen
supabase functions new scan-certificates

# Lokal testen
supabase functions serve

# Deployen
supabase functions deploy scan-certificates
```

**7. Go Agent fÃ¼r Intranet:**
```bash
# Agent entwickelt
# Kommuniziert mit Supabase REST API
# Als Docker Container deployen
```

### ðŸš€ Deployment

**Frontend:**
```bash
# Vercel (empfohlen)
vercel --prod

# Oder Netlify
netlify deploy --prod
```

**Agent:**
```bash
# Railway / Fly.io / Render
fly deploy

# Oder Docker auf eigenem Server
docker build -t certwatcher-agent .
docker run -d certwatcher-agent
```

**Worker (optional):**
- Als Supabase Edge Function (preferred)
- Oder Railway/Render fÃ¼r Python Worker

### âš¡ Quick Start (< 10 Minuten)

```bash
# 1. Supabase Projekt erstellen (2 min)
# â†’ supabase.com â†’ New Project

# 2. Repo clonen & Setup (3 min)
git clone <repo>
cd Zertifikat-WÃ¤chter
make setup

# 3. Credentials konfigurieren (1 min)
cp frontend/.env.example frontend/.env
# Credentials aus Supabase Dashboard eintragen

# 4. Migrations pushen (1 min)
cd supabase
supabase link --project-ref YOUR_PROJECT_REF
supabase db push

# 5. Frontend starten (1 min)
cd frontend
npm run dev

# 6. FERTIG! ðŸŽ‰
# Frontend lÃ¤uft auf http://localhost:5173
# Backend ist Supabase (bereits online)
```

### ðŸ”’ Sicherheits-Checkliste

- [ ] RLS aktiviert auf allen Tabellen
- [ ] Service Role Key NIEMALS im Frontend
- [ ] .env.local in .gitignore
- [ ] CORS richtig konfiguriert in Supabase
- [ ] MFA aktiviert fÃ¼r Admin-Accounts
- [ ] Audit Logging fÃ¼r alle kritischen Aktionen
- [ ] Rate Limiting auf Edge Functions
- [ ] RegelmÃ¤ÃŸige Backups aktiviert

### ðŸ“Š Monitoring & Observability

**Supabase Dashboard:**
- Database â†’ PrÃ¼fe Query Performance
- Auth â†’ User Activity
- Storage â†’ Usage Statistics
- Edge Functions â†’ Logs & Invocations

**Custom Monitoring:**
```typescript
// Fehler-Tracking mit Sentry
import * as Sentry from "@sentry/react"

Sentry.init({
  dsn: "YOUR_SENTRY_DSN",
  integrations: [new Sentry.BrowserTracing()],
})
```

---

## Als KI-Assistent in Cursor:

1. **Lies** die Anforderung genau
2. **Plane** welche Komponenten betroffen sind (Frontend, Edge Functions, Agent)
3. **Schreibe** produktionsnahen Code:
   - Frontend: Supabase Client, RLS-aware Queries, Realtime
   - Edge Functions: Deno/TypeScript, Service Role
   - Agent: Go mit Supabase REST Client
4. **Validiere** Sicherheit (RLS, Credentials, Tenant-Isolation)
5. **Dokumentiere** Setup-Schritte

### Frage nach wenn:
- Supabase Credentials fehlen oder unklar sind
- RLS Policies komplex werden (Performance?)
- Edge Functions vs. Python Worker Trade-offs
- Security-relevante Entscheidungen (Service Role Usage)
- Breaking Changes an DB Schema

### Ziel:
Ein lauffÃ¤higes SaaS-MVP, das in **< 10 Minuten** deployed werden kann, mit:
- âœ… Multi-Tenant-fÃ¤hig (RLS)
- âœ… Produktionsbereit
- âœ… Skalierbar
- âœ… Sicher
- âœ… Wartbar

**Supabase macht's mÃ¶glich! ðŸš€**
